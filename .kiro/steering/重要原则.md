---
inclusion: always
---

# 简庐管理后台系统 - 核心开发原则

## 原则1：奥卡姆剃刀 (Occam's Razor)

### 核心理念
**"如无必要，勿增实体"** (Entities must not be multiplied beyond necessity.)

### 具体要求
- **慎用测试页面** - 避免为验证小问题创建额外的测试文件
- **从源头解决问题** - 直接修复原始代码，而不是绕道而行
- **选择最简方案** - 在多个解决方案中，优先选择最简单有效的

### 实践指导
- 发现问题时，首先考虑能否直接在源码中修复
- 避免创建不必要的中间层、适配器或临时文件
- 重构时删除冗余代码和无用功能
- 保持代码结构简洁清晰

---

## 原则2：希波克拉底誓言 (The Hippocratic Oath)

### 核心理念
**"首先，不造成新的伤害"** (First, do no harm.)

### 具体要求
- **系统完整性优先** - 任何修复都不能破坏现有正常功能
- **影响范围评估** - 修改前必须评估对整个系统的潜在影响
- **渐进式改进** - 采用小步快跑的方式，避免大幅度变更
- **保持敬畏心** - 承认自己无法看到系统的全貌

### 实践指导
- 修改前询问：这会影响其他功能吗？
- 每次只解决一个问题，避免同时修改多个模块
- 修改后进行充分的回归测试
- 对关键功能保持额外的谨慎
- 不要只盯着正在修复的问题，要考虑整个系统

---

## 原则3：拒绝"局部最优解" (Reject Local Optima)

### 核心理念
**"永远记得当前任务服务于一个更高的目标"** - 完成一个健壮完整的软件项目

### 具体要求
- **避免短视行为** - 不为了快速交付而使用后续必须重新开发的代码
- **考虑长远影响** - 每个决策都要考虑对整个项目的长期影响
- **拒绝技术债务** - 不使用硬编码、假数据等临时解决方案
- **追求可持续发展** - 优先选择可维护、可扩展的解决方案

### 实践指导
- 问自己：这个解决方案在6个月后还适用吗？
- 避免为了赶进度而降低代码质量
- 投资时间在正确的架构设计上
- 建立可复用的组件和模式
- 优先考虑系统的整体健康度

### 常见反例
- 为了快速交付使用硬编码配置
- 使用假数据而不建立真实的数据流
- 复制粘贴代码而不抽象公共逻辑
- 跳过测试以节省开发时间
- 忽略错误处理和边界情况

### 🚨 硬编码命名规则（强制执行）
**如果必须使用硬编码数据，变量名必须加上 `-temp` 后缀**

```javascript
// ✅ 正确：明确标识临时硬编码
const activityTypesTemp = [
    { value: 'meeting', label: '会议' },
    { value: 'event', label: '活动' }
];

// ❌ 错误：看起来像正式实现
const activityTypes = [
    { value: 'meeting', label: '会议' },
    { value: 'event', label: '活动' }
];
```

**规则目的：**
- 让硬编码在代码中显而易见
- 提醒开发者这是临时方案
- 便于后续搜索和替换
- 防止硬编码被误认为正式实现

---

## 原则4：先例优先思维 (Precedent-First Thinking)

### 核心理念
**"不要重新发明轮子，先寻找现有的成功模式"** - 在现有系统中寻找类似功能的实现方式

### 具体要求
- **代码考古优先** - 开发新功能前，先调研现有系统的实现方式
- **模式识别能力** - 识别项目中的成功模式并复用
- **系统一致性** - 确保新功能与现有功能在交互和视觉上保持一致
- **避免重复造轮子** - 优先使用现有组件和工具，而不是重新实现

### 实践指导
- 遇到新需求时，先问：系统中有类似的功能吗？
- 查看现有代码中的成功实现，理解其模式和原理
- 复用现有的组件、工具和方法
- 保持与现有功能的一致性体验
- 只有在现有方案确实不适用时，才考虑创建新的实现

### 🎯 实际案例：团队类型模态框问题

#### ❌ 错误做法（重新发明轮子）
```javascript
// 从零开始创建模态框，与Bootstrap样式对抗
const modalHtml = `<div class="modal">...</div>`;
modalElement.style.display = 'flex';
modalElement.style.position = 'fixed';
// ... 大量手动样式设置
```

#### ✅ 正确做法（先例优先）
```javascript
// 查看用户管理页面的实现，发现系统已有Components.createModal
const modal = Components.createModal({
    title: '新增团队类型',
    content: modalContent,
    footer: footerContent
});
```

### 🔍 寻找先例的方法

#### 1. 功能相似性分析
- **相同的UI组件**：模态框、表格、表单、按钮等
- **相同的交互模式**：增删改查、搜索筛选、分页等
- **相同的数据处理**：API调用、错误处理、状态管理等

#### 2. 代码搜索技巧
```bash
# 搜索模态框相关代码
grep -r "createModal\|modal" src/
grep -r "新增.*用户\|创建.*用户" src/

# 搜索API调用模式
grep -r "API\." src/
grep -r "fetch.*api" src/
```

#### 3. 文件结构分析
- 查看类似功能的文件组织方式
- 理解命名约定和目录结构
- 学习现有的架构模式

### 📋 先例优先检查清单

#### 开发新功能前
- [ ] 系统中是否有类似的功能？
- [ ] 现有功能是如何实现的？
- [ ] 可以复用哪些现有组件？
- [ ] 现有的交互模式是什么？
- [ ] 有哪些成功的代码模式可以借鉴？

#### 实现过程中
- [ ] 是否保持了与现有功能的一致性？
- [ ] 是否复用了现有的工具和方法？
- [ ] 是否遵循了现有的命名约定？
- [ ] 是否符合现有的架构模式？

#### 完成后检查
- [ ] 新功能与现有功能的体验是否一致？
- [ ] 是否引入了不必要的新模式？
- [ ] 代码风格是否与项目保持一致？
- [ ] 是否可以进一步抽象为可复用组件？

### 🎓 深层价值

#### 1. 提高开发效率
- 减少从零开始的时间
- 避免重复踩坑
- 快速达到生产质量

#### 2. 保证系统一致性
- 用户体验统一
- 代码风格一致
- 维护成本降低

#### 3. 降低风险
- 使用经过验证的方案
- 减少引入新bug的可能
- 提高代码稳定性

#### 4. 促进知识传承
- 学习现有系统的设计思路
- 理解项目的架构演进
- 建立团队的共同语言

### ⚠️ 注意事项

#### 不要盲目复制
- 理解先例的适用场景
- 根据具体需求进行适配
- 避免生搬硬套不合适的模式

#### 保持创新精神
- 先例优先不等于拒绝创新
- 当现有方案确实不适用时，勇于创新
- 新的优秀实现可以成为未来的先例

---

## 原则5：上下游联动原则 (Upstream-Downstream Coordination)

### 核心理念
**"改动一处，检查上下游"** - 任何代码修改都要考虑直接相关的上游和下游是否需要相应调整

### 具体要求
- **一层追溯** - 检查修改点的直接上游（调用者）和直接下游（被调用者）
- **接口一致性** - 确保修改后的接口与上下游的期望保持一致
- **及时同步** - 发现上下游需要调整时，一并完成修改

### 实践指导
- 修改函数时，检查所有调用该函数的地方
- 修改数据结构时，检查所有使用该数据的地方
- 修改API接口时，检查前端调用和后端实现
- 修改数据库字段时，检查ORM模型和业务逻辑

### ⚠️ 实用边界
**只追溯1层的原因**:
- **效率平衡** - 避免无限追溯导致的分析瘫痪
- **影响范围** - 直接相关的上下游最容易受影响
- **实用性** - 1层追溯能解决80%的关联问题

---

## 原则应用示例

### ✅ 正确做法
```javascript
// 发现权限检查不一致问题
// 直接统一API调用方式
Auth.hasPermission(['user:create'])  // 统一格式
```

### ❌ 错误做法
```javascript
// 创建适配器来兼容不同格式
const PermissionAdapter = {
    check: (perm) => {
        if (Array.isArray(perm)) return Auth.hasPermission(perm);
        return Auth.hasPermission([perm]);
    }
}
```

### ✅ 正确做法 (原则3示例)
```javascript
// 建立可复用的团队类型管理系统
const TeamTypeManager = {
    async loadTeamTypes() {
        // 从后端API获取数据，而不是硬编码
        const response = await API.get('/teams/types');
        return response.data;
    }
};
```

### ❌ 错误做法 (违反原则3)
```javascript
// 为了快速交付使用硬编码
const teamTypes = [
    'general', 'development', 'testing'  // 硬编码，后续难以维护
];
```

### ✅ 正确做法 (原则4示例)
```javascript
// 参考用户管理的模态框实现
const modal = Components.createModal({
    title: '新增团队类型',
    content: formContent,
    modalType: 'team-type-create'
});
```

### ❌ 错误做法 (违反原则4)
```javascript
// 从零开始实现模态框，忽略现有的成功方案
const modalElement = document.createElement('div');
modalElement.className = 'custom-modal';
// ... 大量重复的实现代码
```

### ✅ 正确做法
```css
/* 搜索框边框问题 - 直接修复CSS */
.search-input-group {
    border: 1px solid #ced4da;
    border-radius: 4px;
}
```

### ❌ 错误做法
```html
<!-- 创建测试页面验证边框效果 -->
<!-- test-search-border.html -->
```

---

## 违反原则的后果

### 违反奥卡姆剃刀原则
- 代码复杂度增加
- 维护成本上升
- 引入不必要的依赖
- 项目文件冗余

### 违反希波克拉底誓言
- 修复一个问题引入新问题
- 系统稳定性下降
- 用户体验受损
- 开发效率降低

### 违反拒绝局部最优解原则
- 积累大量技术债务
- 后期重构成本巨大
- 系统架构逐渐腐化
- 开发速度越来越慢

### 违反先例优先思维原则
- 重复造轮子，浪费开发时间
- 系统一致性被破坏
- 引入不必要的复杂性
- 增加维护和学习成本
- 用户体验不一致

### 违反上下游联动原则
- 修改引入新的接口不兼容问题
- 上下游数据格式不匹配
- 功能局部正常但整体异常
- 多轮返工和调试时间增加

---

## 检查清单

### 开始修改前
- [ ] 这是最简单的解决方案吗？（原则1）
- [ ] 是否需要创建额外的文件或组件？（原则1）
- [ ] 修改会影响哪些其他功能？（原则2）
- [ ] 有没有更直接的修复方式？（原则1）
- [ ] 这个解决方案在6个月后还适用吗？（原则3）
- [ ] 是否在为了速度而牺牲质量？（原则3）
- [ ] 如果使用硬编码，是否已添加-temp后缀？（硬编码规则）
- [ ] 系统中是否有类似功能的实现？（原则4）
- [ ] 是否可以复用现有的组件和模式？（原则4）
- [ ] 修改点的直接上游（调用者）是否需要调整？（原则5）
- [ ] 修改点的直接下游（被调用者）是否需要调整？（原则5）

### 修改完成后
- [ ] 原有功能是否正常工作？（原则2）
- [ ] 是否引入了新的复杂性？（原则1）
- [ ] 代码是否比之前更简洁？（原则1）
- [ ] 需要清理哪些临时文件？（原则1）
- [ ] 这个方案是否可维护和可扩展？（原则3）
- [ ] 是否为项目的长期健康做出了贡献？（原则3）
- [ ] 所有硬编码是否都有-temp后缀？（硬编码规则）
- [ ] 是否已计划何时移除硬编码？（硬编码规则）
- [ ] 新功能与现有功能的体验是否一致？（原则4）
- [ ] 是否遵循了现有的代码模式和约定？（原则4）
- [ ] 上下游的接口和数据格式是否保持一致？（原则5）
- [ ] 相关的调用者和被调用者是否都已同步更新？（原则5）

---

## 总结

这五个原则是所有开发工作的指导思想：

1. **简单至上** - 用最简单的方式解决问题
2. **安全第一** - 确保修改不会破坏现有功能
3. **长远考虑** - 为项目的可持续发展负责
4. **先例优先** - 在现有系统中寻找成功模式并复用
5. **上下游联动** - 修改时检查直接相关的调用者和被调用者

遵循这些原则，可以：
- 提高代码质量
- 降低维护成本
- 减少系统风险
- 提升开发效率
- 建立健壮的软件架构
- 保持系统一致性
- 促进知识传承和团队协作

> 💡 **记住**：好的开发者不是能写出复杂代码的人，而是能用简单方式解决复杂问题，同时不破坏系统稳定性，为项目长远发展负责，善于学习和复用现有成功模式，并在修改时考虑上下游影响的人。